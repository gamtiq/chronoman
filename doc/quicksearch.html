<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"chronoman.js.html":{"id":"chronoman.js.html","title":"Source: chronoman.js","body":" chronoman Modules chronoman Classes chronoman~Timer Source: chronoman.js /** * @module chronoman * * @author Denis Sikuler */ if (! Array.isArray) { Array.isArray = function(value) { return Object.prototype.toString.call(value) === \"[object Array]\"; }; } /** * @callback module:chronoman~GetPeriodValue * @param {module:chronoman~Timer} [timer] * @return {Integer | Integer[]} */ /** * Value determining time period in milliseconds that is used to schedule related action execution. * * @typedef {Integer | Integer[] | module:chronoman~GetPeriodValue} module:chronoman~PeriodValue */ /** * Object describing action that should be executed after time period is elapsed. * * @typedef {Object} module:chronoman~ActionObject * @property {Function} execute * Function that should be executed. */ /** * Action that should be executed after time period is elapsed. * * @typedef {Function | module:chronoman~ActionObject} module:chronoman~Action */ /** * Utility class to simplify use of timers created by setTimeout. * * @param {Object} [initValue] * Specifies initial property values. Keys are property names, their values are values of corresponding properties. * See {@link module:chronoman~Timer#setProperties setProperties} for details. * @constructor * @see {@link module:chronoman~Timer#setProperties setProperties} */ var Timer = function Timer(initValue) { var that = this; this._executeTime = []; /** * Handle timeout's end. * * @instance * @method * @protected * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} * @see {@link module:chronoman~Timer#execute execute} */ this._onTimeoutEnd = function() { that._timeoutId = null; that.execute(); }; if (initValue &amp;&amp; typeof initValue === \"object\") { this.setProperties(initValue); } }; /** * Time period in milliseconds, array of periods or function that returns period or array of periods. * A related action will be executed when the period is elapsed. * &lt;br&gt; * When array of periods is set the used period is selected in the following way: * first array item (with index 0) specifies period before first action's execution, * second array item (with index 1) specifies period before second action's execution, * and so on. * When quantity of action executions is more than array's length * the last item of array is used as period for subsequent executions. * &lt;br&gt; * When function is set its returned value is used to determine next period. * The timer instance to which the function is associated will be passed as function's parameter. * When function returns an array of periods the array is used to select period before next execution * according to rules described above. * * @protected * @type {module:chronoman~PeriodValue} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._period = null; /** * Return value determining time period that is used to schedule related action execution. * * @return {module:chronoman~PeriodValue} * Value determining time period. * @method * @see {@link module:chronoman~Timer#_period _period} */ Timer.prototype.getPeriod = function() { return this._period; }; /** * Set value determining time period that is used to schedule related action execution. * * @param {module:chronoman~PeriodValue} period * Value determining time period. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_period _period} */ Timer.prototype.setPeriod = function(period) { this._period = period; return this; }; /** * Return time period that will be used to schedule related action execution. * * @return {Integer} * Time period in milliseconds. * @method * @see {@link module:chronoman~Timer#_period _period} * @see {@link module:chronoman~Timer#getPeriod getPeriod} * @see {@link module:chronoman~Timer#getExecutionQty getExecutionQty} */ Timer.prototype.getPeriodValue = function() { var execQty; var period = this.getPeriod(); if (typeof period === \"function\") { period = period(this); } if (Array.isArray(period)) { execQty = this.getExecutionQty(); period = period[ execQty &lt; period.length ? execQty : period.length - 1 ]; } return period; }; /** * Indicates whether related action should be executed repeatedly. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._recurrent = false; /** * Test whether related action should be executed repeatedly. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if related action should be executed repeatedly, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_recurrent _recurrent} */ Timer.prototype.isRecurrent = function() { return this._recurrent; }; /** * Set or cancel repeating of related action execution. * * @param {Boolean} bRecurrent * &lt;code&gt;true&lt;/code&gt;, if action should be executed repeatedly, &lt;code&gt;false&lt;/code&gt;, if action repeating should be off. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_recurrent _recurrent} */ Timer.prototype.setRecurrent = function(bRecurrent) { this._recurrent = bRecurrent; return this; }; /** * Specifies how many times related action should be repeated after first execution. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._repeatQty = 0; /** * Return the value that indicates how many times related action should be repeated after first execution. * * @return {Integer} * Value that indicates how many times related action should be repeated after first execution. * @method * @see {@link module:chronoman~Timer#_repeatQty _repeatQty} */ Timer.prototype.getRepeatQty = function() { return this._repeatQty; }; /** * Set how many times related action should be repeated after first execution. * * @param {Integer} nQty * Value that indicates how many times related action should be repeated after first execution. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_repeatQty _repeatQty} */ Timer.prototype.setRepeatQty = function(nQty) { this._repeatQty = nQty; return this; }; /** * Specifies function that should be called after action execution to determine * whether execution should be repeated. * If the function returns a true value or non-negative number it means that execution will be repeated. * When the function returns non-negative number this number will be used * as time period in milliseconds to schedule next action execution. * &lt;br&gt; * The timer instance to which the test is associated will be passed as function's parameter. * * @protected * @type {Function} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._repeatTest = null; /** * Return the function that is used to determine whether action execution should be repeated. * * @return {Function} * Function that is used to determine whether action execution should be repeated. * @method * @see {@link module:chronoman~Timer#_repeatTest _repeatTest} */ Timer.prototype.getRepeatTest = function() { return this._repeatTest; }; /** * Set the function that should be used to determine whether action execution should be repeated. * * @param {Function} test * Function that should be used to determine whether action execution should be repeated. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_repeatTest _repeatTest} */ Timer.prototype.setRepeatTest = function(test) { this._repeatTest = test; return this; }; /** * Auxiliary data associated with the timer instance. * * @protected * @type {*} */ Timer.prototype._data = null; /** * Return auxiliary data associated with the timer instance. * * @return {*} * Auxiliary data associated with the timer instance. * @method * @see {@link module:chronoman~Timer#_data _data} */ Timer.prototype.getData = function() { return this._data; }; /** * Set auxiliary data associated with the timer instance. * * @param {*} data * Auxiliary data associated with the timer instance. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_data _data} */ Timer.prototype.setData = function(data) { this._data = data; return this; }; /** * Specifies how many times action was executed. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._executionQty = 0; /** * Return the value that indicates how many times action was executed. * * @return {Integer} * Value that indicates how many times action was executed. * @method * @see {@link module:chronoman~Timer#_executionQty _executionQty} */ Timer.prototype.getExecutionQty = function() { return this._executionQty; }; /** * Set the value that indicates how many times action was executed. * * @param {Integer} nQty * Value that indicates how many times action was executed. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_executionQty _executionQty} */ Timer.prototype.setExecutionQty = function(nQty) { this._executionQty = nQty &gt; 0 ? nQty : 0; return this; }; /** * Timer id. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#_clearTimeout _clearTimeout} * @see {@link module:chronoman~Timer#_setTimeout _setTimeout} */ Timer.prototype._timeoutId = null; /** * Schedule related action execution. * * @param {Integer} [nTimeout] * Time period in milliseconds that is used to schedule action execution. * By default the current value of {@link module:chronoman~Timer#getPeriod period} property is used * to determine time period. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @protected * @see {@link module:chronoman~Timer#_clearTimeout _clearTimeout} * @see {@link module:chronoman~Timer#_onTimeoutEnd _onTimeoutEnd} * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#getPeriodValue getPeriodValue} */ Timer.prototype._setTimeout = function(nTimeout) { \"use strict\"; var period; if (typeof nTimeout === \"number\") { period = nTimeout; } else { period = this.getPeriodValue(); } if (typeof period === \"number\") { this._timeoutId = setTimeout(this._onTimeoutEnd, period); } return this; }; /** * Cancel execution of scheduled action. * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @protected * @see {@link module:chronoman~Timer#_setTimeout _setTimeout} * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} */ Timer.prototype._clearTimeout = function() { \"use strict\"; if (this._timeoutId) { clearTimeout(this._timeoutId); this._timeoutId = null; } return this; }; /** * Time when timer was set {@link module:chronoman~Timer#_active active} * (was {@link module:chronoman~Timer#start started}). * * @protected * @type {Integer | null} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start start} */ Timer.prototype._startTime = null; /** * Return time when timer was set active. * * @return {Integer | null} * Time when timer was set active. * @method * @see {@link module:chronoman~Timer#_startTime _startTime} */ Timer.prototype.getStartTime = function() { return this._startTime; }; /** * Time when timer was set {@link module:chronoman~Timer#_active inactive} * (was {@link module:chronoman~Timer#start stopped}). * * @protected * @type {Integer | null} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start stop} */ Timer.prototype._stopTime = null; /** * Return time when timer was set inactive. * * @return {Integer | null} * Time when timer was set inactive. * @method * @see {@link module:chronoman~Timer#_stopTime _stopTime} */ Timer.prototype.getStopTime = function() { return this._stopTime; }; /** * List that contain times when {@link module:chronoman~Timer#execute execute} was called. * * @type {Integer[]} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._executeTime = null; /** * Return list that contain times when {@link module:chronoman~Timer#execute execute} was called. * * @return {Integer[]} * List that contain times when {@link module:chronoman~Timer#execute execute} was called. * @method * @see {@link module:chronoman~Timer#_executeTime _executeTime} */ Timer.prototype.getExecuteTime = function() { return this._executeTime; }; /** * Indicates whether timer is in use. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._active = false; /** * Test whether timer is in use. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if timer is in use, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_active _active} */ Timer.prototype.isActive = function() { return this._active; }; /** * Set or cancel timer usage. * Depending of this schedules related action execution or cancels action execution. * &lt;br&gt; * Consecutive calling with &lt;code&gt;bActive = true&lt;/code&gt; leads to related action execution delaying. * * @param {Boolean} bActive * &lt;code&gt;true&lt;/code&gt; to schedule related action execution, &lt;code&gt;false&lt;/code&gt; to cancel action execution. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_active _active} * @see {@link module:chronoman~Timer#_executionQty _executionQty} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype.setActive = function(bActive) { \"use strict\"; if (bActive &amp;&amp; ! this._active) { this._executionQty = 0; } this._active = bActive; // Consecutive calling with bActive = true leads to action execution delaying this._clearTimeout(); if (bActive) { this._executeTime.length = 0; this._setTimeout(); } this[bActive ? \"_startTime\" : \"_stopTime\"] = new Date().getTime(); return this; }; /** * Start timer usage (make it active). * * @param {module:chronoman~PeriodValue | Object} [property] * Time period in milliseconds that is used to schedule related action execution * (new value for {@link module:chronoman~Timer#setPeriod period} property) * or object that specifies new values for timer properties (see {@link module:chronoman~Timer#setProperties setProperties}). * The current value of {@link module:chronoman~Timer#getPeriod period} property is used by default. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#setPeriod setPeriod} * @see {@link module:chronoman~Timer#setProperties setProperties} * @see {@link module:chronoman~Timer#stop stop} */ Timer.prototype.start = function(property) { \"use strict\"; var propType = typeof property; if (propType === \"number\" || propType === \"function\" || Array.isArray(property)) { this.setPeriod(property); } else if (property &amp;&amp; propType === \"object\") { this.setProperties(property); } return this.setActive(true); }; /** * Stop timer usage (make it inactive). * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start start} */ Timer.prototype.stop = function() { return this.setActive(false); }; /** * Related action that should be executed after time period is elapsed. * &lt;br&gt; * Can be a function or an object having &lt;code&gt;execute&lt;/code&gt; method. * &lt;br&gt; * The timer instance to which the action is associated will be passed as function's/method's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * * @protected * @type {module:chronoman~Action} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._action = null; /** * Return value that represents action. * * @return {module:chronoman~Action} * Function that represents action. * @method * @see {@link module:chronoman~Timer#_action _action} */ Timer.prototype.getAction = function() { return this._action; }; /** * Set value which represents action that should be executed after time period is elapsed. * * @param {module:chronoman~Action} action * Value that represents action. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_action _action} */ Timer.prototype.setAction = function(action) { this._action = action; return this; }; /** * Indicates whether the timer instance (&lt;code&gt;this&lt;/code&gt;) should be passed into action function when the function is called. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._passToAction = false; /** * Test whether the timer instance should be passed into action function when the function is called. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if the timer instance should be passed, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_passToAction _passToAction} */ Timer.prototype.isPassToAction = function() { return this._passToAction; }; /** * Set or cancel passing of timer instance into action function. * * @param {Boolean} bPass * &lt;code&gt;true&lt;/code&gt;, if the timer instance should be passed into action function, * &lt;code&gt;false&lt;/code&gt;, if the instance should not be passed. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_passToAction _passToAction} */ Timer.prototype.setPassToAction = function(bPass) { this._passToAction = bPass; return this; }; /** * Set timer properties. * * @param {Object} propMap * Specifies property values. Keys are property names, their values are values of corresponding properties. * The following keys (properties) can be specified: * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;Name&lt;/th&gt; * &lt;th&gt;Type&lt;/th&gt; * &lt;th&gt;Description&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;action&lt;/td&gt; * &lt;td&gt;Function&lt;/td&gt; * &lt;td&gt;Related action that should be executed after time period is elapsed.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;active&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether timer usage should be immediately started.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;data&lt;/td&gt; * &lt;td&gt;Any&lt;/td&gt; * &lt;td&gt;Auxiliary data associated with the timer instance.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;passToAction&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether the timer instance should be passed into action function when the function is called.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;period&lt;/td&gt; * &lt;td&gt;module:chronoman~PeriodValue&lt;/td&gt; * &lt;td&gt;Value determining time period in milliseconds that is used to schedule related action execution.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;recurrent&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether related action should be executed repeatedly.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;repeatQty&lt;/td&gt; * &lt;td&gt;Integer&lt;/td&gt; * &lt;td&gt;How many times related action should be repeated after first execution.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;repeatTest&lt;/td&gt; * &lt;td&gt;Function&lt;/td&gt; * &lt;td&gt;Function that should be used to determine whether action execution should be repeated.&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setAction setAction} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#setData setData} * @see {@link module:chronoman~Timer#setPassToAction setPassToAction} * @see {@link module:chronoman~Timer#setPeriod setPeriod} * @see {@link module:chronoman~Timer#setRecurrent setRecurrent} * @see {@link module:chronoman~Timer#setRepeatQty setRepeatQty} * @see {@link module:chronoman~Timer#setRepeatTest setRepeatTest} */ Timer.prototype.setProperties = function(propMap) { if (propMap &amp;&amp; typeof propMap === \"object\") { if (\"action\" in propMap) { this.setAction(propMap.action); } if (\"period\" in propMap) { this.setPeriod(propMap.period); } if (\"recurrent\" in propMap) { this.setRecurrent(propMap.recurrent); } if (\"repeatQty\" in propMap) { this.setRepeatQty(propMap.repeatQty); } if (\"repeatTest\" in propMap) { this.setRepeatTest(propMap.repeatTest); } if (\"active\" in propMap) { this.setActive(propMap.active); } if (\"passToAction\" in propMap) { this.setPassToAction(propMap.passToAction); } if (\"data\" in propMap) { this.setData(propMap.data); } } return this; }; /** * Result of {@link module:chronoman~Timer#_action action}'s last execution. * * @type {*} * @see {@link module:chronoman~Timer#_action action} */ Timer.prototype.actionResult = void 0; /** * Function that should be executed after time period is elapsed. * &lt;br&gt; * The timer instance to which the function is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * * @type {Function} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype.onExecute = null; /** * Result of {@link module:chronoman~Timer#onExecute onExecute} last execution. * * @type {*} * @see {@link module:chronoman~Timer#onExecute onExecute} */ Timer.prototype.onExecuteResult = void 0; /** * Execute related action (function). * &lt;br&gt; * The timer instance to which the action is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * &lt;br&gt; * Action's next execution will be scheduled when one of the following conditions is true: * &lt;ul&gt; * &lt;li&gt;timer is set as recurrent (see {@link module:chronoman~Timer#isRecurrent isRecurrent}); * &lt;li&gt;specified quantity of repeats is not reached (see {@link module:chronoman~Timer#getRepeatQty getRepeatQty}); * &lt;li&gt;specified repeat test is passed i.e. the test function returns true value or non-negative number (see {@link module:chronoman~Timer#getRepeatTest getRepeatTest}); * &lt;/ul&gt; * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_active _active} * @see {@link module:chronoman~Timer#_executionQty _executionQty} * @see {@link module:chronoman~Timer#getAction getAction} * @see {@link module:chronoman~Timer#getRepeatQty getRepeatQty} * @see {@link module:chronoman~Timer#getRepeatTest getRepeatTest} * @see {@link module:chronoman~Timer#isActive isActive} * @see {@link module:chronoman~Timer#isPassToAction isPassToAction} * @see {@link module:chronoman~Timer#isRecurrent isRecurrent} * @see {@link module:chronoman~Timer#onExecute onExecute} */ Timer.prototype.execute = function() { \"use strict\"; /*jshint expr:true, laxbreak:true*/ var action = this.getAction(), bPassToAction = this.isPassToAction(), repeatTest = this.getRepeatTest(), bActive, period; this._clearTimeout(); if (action) { if (typeof action === \"function\") { this.actionResult = bPassToAction ? action(this) : action(); } else if (typeof action.execute === \"function\") { this.actionResult = bPassToAction ? action.execute(this) : action.execute(); } } if (typeof this.onExecute === \"function\") { this.onExecuteResult = bPassToAction ? this.onExecute(this) : this.onExecute(); } this._executionQty++; this._executeTime.push( new Date().getTime() ); bActive = this.isActive(); if (bActive &amp;&amp; (this.isRecurrent() || this.getRepeatQty() &gt;= this._executionQty || (repeatTest &amp;&amp; ( (period = repeatTest(this)) || period === 0 ) &amp;&amp; (typeof period !== \"number\" || period &gt;= 0)) ) ) { this._setTimeout(period); } else if (bActive &amp;&amp; ! this._timeoutId) { this.setActive(false); } return this; }; /** * Free resources that are allocated for object. * * @method */ Timer.prototype.dispose = function() { \"use strict\"; this._clearTimeout(); this._action = this.actionResult = this._data = this._executeTime = this._period = this._repeatTest = this.onExecute = this.onExecuteResult = null; }; /** * Convert object into string. * * @method */ Timer.prototype.toString = function() { \"use strict\"; /*jshint laxbreak:true*/ var period = this.getPeriod(), startTime = this.getStartTime(), stopTime = this.getStopTime(), executeTime = this.getExecuteTime(), nL = executeTime.length, execTime = \"\", nI; if (nL) { for (nI = 0; nI &lt; nL; nI++) { execTime += (nI ? \"; \" : \"\") + new Date( executeTime[nI] ); } } return [ \"Timer: \", \"active - \", this.isActive(), \", period - \", typeof period === \"function\" ? \"function\" : period, \", recurrent - \", this.isRecurrent(), \", repeat qty - \", this.getRepeatQty(), \", repeat test - \", (this.getRepeatTest() ? \"specified\" : \"no\"), \", pass to action - \", this.isPassToAction(), \", action - \", (this.getAction() ? \"specified\" : \"no\"), \", execution qty - \", this.getExecutionQty(), typeof startTime === \"number\" ? \", start time - \" + new Date(startTime) : \"\", execTime ? \", execute time - \" + execTime : \"\", typeof stopTime === \"number\" ? \", stop time - \" + new Date(stopTime) : \"\", \", action result - \", this.actionResult, \", onExecuteResult - \", this.onExecuteResult, \", data - \", this.getData() ].join(\"\"); }; // Exports export default Timer; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" chronoman Modules chronoman Classes chronoman~Timer Modules Classes Timer × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" chronoman Modules chronoman Classes chronoman~Timer Classes Classes Timer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" chronoman Modules chronoman Classes chronoman~Timer chronomanUtility class to simplify use of timers created by setTimeout. var timer = new Timer({ period: [100, 200, 300, 400, 500], repeatQty: 100, passToAction: true, action: function(tmr) { console.log(\"#\", tmr.getExecutionQty() + 1, \":\", new Date()); }, active: true }); ... timer.stop(); InstallationNodenpm install chronomanJSPMjspm install chronomanBowerbower install chronomanAMD, &lt;script&gt;Use dist/chronoman.js or dist/chronoman.min.js (minified version). UsageECMAScript 6/2015import Timer from \"chronoman\";Node, JSPMvar Timer = require(\"chronoman\");JSPMSystem.import(\"chronoman\").then(function(Timer) { ... });AMDdefine([\"path/to/dist/chronoman.js\"], function(Timer) { ... });Bower, &lt;script&gt;&lt;!-- Use bower_components/chronoman/dist/chronoman.js if the library was installed by Bower --&gt; &lt;script type=\"text/javascript\" src=\"path/to/dist/chronoman.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // сhronoman is available via Chronoman field of window object var Timer = Chronoman; ... &lt;/script&gt;Examplevar tmrOne = new Timer({ period: function(timer) { return 1000 + (timer.getExecutionQty() * 100); }, action: function(timer) { console.log(\"---&gt; Timer one. \", timer); if (! tmrThree.isActive()) { tmrThree.start(); } } }); var tmrTwo = new Timer(); tmrTwo.setPeriod([2000, 1500]) .setRepeatQty(9) .setPassToAction(true) .setAction({ i: 0, execute: function(timer) { var nI = ++this.i; console.log(\"Timer two. #\", nI, timer); tmrOne.setActive(nI % 2 === 1); } }); var tmrThree = new Timer() .setPeriod(3000) .setRepeatTest(function() { return tmrTwo.isActive(); }); tmrThree.onExecute = function() { console.log(\"* Timer three. #\", this.getExecutionQty() + 1); }; tmrTwo.start();See test/chronoman.js for additional examples. APISee doc folder. Related projects NumGen povtor InspirationThis module is inspired by qooxdoo's qx.event.Timer class. LicenceCopyright (c) 2013-2019 Denis SikulerLicensed under the MIT license. × Search results Close "},"module-chronoman.html":{"id":"module-chronoman.html","title":"Module: chronoman","body":" chronoman Modules chronoman Classes chronoman~Timer Module: chronoman Author: Denis Sikuler Source: chronoman.js, line 1 Classes Timer Type Definitions Action() Action that should be executed after time period is elapsed. Source: chronoman.js, line 34 ActionObject Object describing action that should be executed after time period is elapsed. Type: Object Properties: Name Type Description execute function Function that should be executed. Source: chronoman.js, line 26 GetPeriodValue( [timer]) Parameters: Name Type Argument Description timer module:chronoman~Timer &lt;optional&gt; Source: chronoman.js, line 14 Returns: Type Integer | Array.&lt;Integer&gt; PeriodValue Value determining time period in milliseconds that is used to schedule related action execution. Type: Integer | Array.&lt;Integer&gt; | module:chronoman~GetPeriodValue Source: chronoman.js, line 20 × Search results Close "},"module-chronoman-Timer.html":{"id":"module-chronoman-Timer.html","title":"Class: Timer","body":" chronoman Modules chronoman Classes chronoman~Timer Class: Timer chronoman~ Timer new Timer( [initValue]) Utility class to simplify use of timers created by setTimeout. Parameters: Name Type Argument Description initValue Object &lt;optional&gt; Specifies initial property values. Keys are property names, their values are values of corresponding properties. See setProperties for details. Source: chronoman.js, line 50 See: setProperties Members &lt;protected&gt; _action :module:chronoman~Action Related action that should be executed after time period is elapsed. Can be a function or an object having execute method. The timer instance to which the action is associated will be passed as function's/method's parameter if passToAction property is set to true. Type: module:chronoman~Action Source: chronoman.js, line 570 See: execute &lt;protected&gt; _active :Boolean Indicates whether timer is in use. Type: Boolean Source: chronoman.js, line 472 See: execute &lt;protected&gt; _data :* Auxiliary data associated with the timer instance. Type: * Source: chronoman.js, line 272 _executeTime :Array.&lt;Integer&gt; List that contain times when execute was called. Type: Array.&lt;Integer&gt; Source: chronoman.js, line 451 See: execute &lt;protected&gt; _executionQty :Integer Specifies how many times action was executed. Type: Integer Source: chronoman.js, line 309 See: execute setActive &lt;protected&gt; _passToAction :Boolean Indicates whether the timer instance (this) should be passed into action function when the function is called. Type: Boolean Source: chronoman.js, line 606 See: execute &lt;protected&gt; _period :module:chronoman~PeriodValue Time period in milliseconds, array of periods or function that returns period or array of periods. A related action will be executed when the period is elapsed. When array of periods is set the used period is selected in the following way: first array item (with index 0) specifies period before first action's execution, second array item (with index 1) specifies period before second action's execution, and so on. When quantity of action executions is more than array's length the last item of array is used as period for subsequent executions. When function is set its returned value is used to determine next period. The timer instance to which the function is associated will be passed as function's parameter. When function returns an array of periods the array is used to select period before next execution according to rules described above. Type: module:chronoman~PeriodValue Source: chronoman.js, line 97 See: execute setActive &lt;protected&gt; _recurrent :Boolean Indicates whether related action should be executed repeatedly. Type: Boolean Source: chronoman.js, line 157 See: execute setActive &lt;protected&gt; _repeatQty :Integer Specifies how many times related action should be repeated after first execution. Type: Integer Source: chronoman.js, line 194 See: execute setActive &lt;protected&gt; _repeatTest :function Specifies function that should be called after action execution to determine whether execution should be repeated. If the function returns a true value or non-negative number it means that execution will be repeated. When the function returns non-negative number this number will be used as time period in milliseconds to schedule next action execution. The timer instance to which the test is associated will be passed as function's parameter. Type: function Source: chronoman.js, line 237 See: execute setActive &lt;protected&gt; _startTime :Integer|null Time when timer was set active (was started). Type: Integer | null Source: chronoman.js, line 408 See: setActive start &lt;protected&gt; _stopTime :Integer|null Time when timer was set inactive (was stopped). Type: Integer | null Source: chronoman.js, line 431 See: setActive stop &lt;protected&gt; _timeoutId :Integer Timer id. Type: Integer Source: chronoman.js, line 346 See: _clearTimeout _setTimeout actionResult :* Result of action's last execution. Type: * Source: chronoman.js, line 737 See: action onExecute :function Function that should be executed after time period is elapsed. The timer instance to which the function is associated will be passed as function's parameter if passToAction property is set to true. Type: function Source: chronoman.js, line 748 See: execute onExecuteResult :* Result of onExecute last execution. Type: * Source: chronoman.js, line 756 See: onExecute Methods &lt;protected&gt; _clearTimeout() Cancel execution of scheduled action. Source: chronoman.js, line 390 See: _setTimeout _timeoutId Returns: Reference to this object. Type Object &lt;protected&gt; _onTimeoutEnd() Handle timeout's end. Source: chronoman.js, line 65 See: _timeoutId execute &lt;protected&gt; _setTimeout( [nTimeout]) Schedule related action execution. Parameters: Name Type Argument Description nTimeout Integer &lt;optional&gt; Time period in milliseconds that is used to schedule action execution. By default the current value of period property is used to determine time period. Source: chronoman.js, line 365 See: _clearTimeout _onTimeoutEnd _timeoutId execute getPeriodValue Returns: Reference to this object. Type Object dispose() Free resources that are allocated for object. Source: chronoman.js, line 832 execute() Execute related action (function). The timer instance to which the action is associated will be passed as function's parameter if passToAction property is set to true. Action's next execution will be scheduled when one of the following conditions is true: timer is set as recurrent (see isRecurrent); specified quantity of repeats is not reached (see getRepeatQty); specified repeat test is passed i.e. the test function returns true value or non-negative number (see getRepeatTest); Source: chronoman.js, line 784 See: _active _executionQty getAction getRepeatQty getRepeatTest isActive isPassToAction isRecurrent onExecute Returns: Reference to this object. Type Object getAction() Return value that represents action. Source: chronoman.js, line 580 See: _action Returns: Function that represents action. Type module:chronoman~Action getData() Return auxiliary data associated with the timer instance. Source: chronoman.js, line 282 See: _data Returns: Auxiliary data associated with the timer instance. Type * getExecuteTime() Return list that contain times when execute was called. Source: chronoman.js, line 461 See: _executeTime Returns: List that contain times when execute was called. Type Array.&lt;Integer&gt; getExecutionQty() Return the value that indicates how many times action was executed. Source: chronoman.js, line 319 See: _executionQty Returns: Value that indicates how many times action was executed. Type Integer getPeriod() Return value determining time period that is used to schedule related action execution. Source: chronoman.js, line 107 See: _period Returns: Value determining time period. Type module:chronoman~PeriodValue getPeriodValue() Return time period that will be used to schedule related action execution. Source: chronoman.js, line 136 See: _period getPeriod getExecutionQty Returns: Time period in milliseconds. Type Integer getRepeatQty() Return the value that indicates how many times related action should be repeated after first execution. Source: chronoman.js, line 204 See: _repeatQty Returns: Value that indicates how many times related action should be repeated after first execution. Type Integer getRepeatTest() Return the function that is used to determine whether action execution should be repeated. Source: chronoman.js, line 247 See: _repeatTest Returns: Function that is used to determine whether action execution should be repeated. Type function getStartTime() Return time when timer was set active. Source: chronoman.js, line 418 See: _startTime Returns: Time when timer was set active. Type Integer | null getStopTime() Return time when timer was set inactive. Source: chronoman.js, line 441 See: _stopTime Returns: Time when timer was set inactive. Type Integer | null isActive() Test whether timer is in use. Source: chronoman.js, line 482 See: _active Returns: true, if timer is in use, otherwise false. Type Boolean isPassToAction() Test whether the timer instance should be passed into action function when the function is called. Source: chronoman.js, line 616 See: _passToAction Returns: true, if the timer instance should be passed, otherwise false. Type Boolean isRecurrent() Test whether related action should be executed repeatedly. Source: chronoman.js, line 167 See: _recurrent Returns: true, if related action should be executed repeatedly, otherwise false. Type Boolean setAction(action) Set value which represents action that should be executed after time period is elapsed. Parameters: Name Type Description action module:chronoman~Action Value that represents action. Source: chronoman.js, line 594 See: _action Returns: Reference to this object. Type Object setActive(bActive) Set or cancel timer usage. Depending of this schedules related action execution or cancels action execution. Consecutive calling with bActive = true leads to related action execution delaying. Parameters: Name Type Description bActive Boolean true to schedule related action execution, false to cancel action execution. Source: chronoman.js, line 501 See: _active _executionQty execute Returns: Reference to this object. Type Object setData(data) Set auxiliary data associated with the timer instance. Parameters: Name Type Description data * Auxiliary data associated with the timer instance. Source: chronoman.js, line 296 See: _data Returns: Reference to this object. Type Object setExecutionQty(nQty) Set the value that indicates how many times action was executed. Parameters: Name Type Description nQty Integer Value that indicates how many times action was executed. Source: chronoman.js, line 333 See: _executionQty Returns: Reference to this object. Type Object setPassToAction(bPass) Set or cancel passing of timer instance into action function. Parameters: Name Type Description bPass Boolean true, if the timer instance should be passed into action function, false, if the instance should not be passed. Source: chronoman.js, line 631 See: _passToAction Returns: Reference to this object. Type Object setPeriod(period) Set value determining time period that is used to schedule related action execution. Parameters: Name Type Description period module:chronoman~PeriodValue Value determining time period. Source: chronoman.js, line 121 See: _period Returns: Reference to this object. Type Object setProperties(propMap) Set timer properties. Parameters: Name Type Description propMap Object Specifies property values. Keys are property names, their values are values of corresponding properties. The following keys (properties) can be specified: Name Type Description action Function Related action that should be executed after time period is elapsed. active Boolean Whether timer usage should be immediately started. data Any Auxiliary data associated with the timer instance. passToAction Boolean Whether the timer instance should be passed into action function when the function is called. period module:chronoman~PeriodValue Value determining time period in milliseconds that is used to schedule related action execution. recurrent Boolean Whether related action should be executed repeatedly. repeatQty Integer How many times related action should be repeated after first execution. repeatTest Function Function that should be used to determine whether action execution should be repeated. Source: chronoman.js, line 701 See: setAction setActive setData setPassToAction setPeriod setRecurrent setRepeatQty setRepeatTest Returns: Reference to this object. Type Object setRecurrent(bRecurrent) Set or cancel repeating of related action execution. Parameters: Name Type Description bRecurrent Boolean true, if action should be executed repeatedly, false, if action repeating should be off. Source: chronoman.js, line 181 See: _recurrent Returns: Reference to this object. Type Object setRepeatQty(nQty) Set how many times related action should be repeated after first execution. Parameters: Name Type Description nQty Integer Value that indicates how many times related action should be repeated after first execution. Source: chronoman.js, line 218 See: _repeatQty Returns: Reference to this object. Type Object setRepeatTest(test) Set the function that should be used to determine whether action execution should be repeated. Parameters: Name Type Description test function Function that should be used to determine whether action execution should be repeated. Source: chronoman.js, line 261 See: _repeatTest Returns: Reference to this object. Type Object start( [property]) Start timer usage (make it active). Parameters: Name Type Argument Description property module:chronoman~PeriodValue | Object &lt;optional&gt; Time period in milliseconds that is used to schedule related action execution (new value for period property) or object that specifies new values for timer properties (see setProperties). The current value of period property is used by default. Source: chronoman.js, line 533 See: setActive setPeriod setProperties stop Returns: Reference to this object. Type Object stop() Stop timer usage (make it inactive). Source: chronoman.js, line 554 See: setActive start Returns: Reference to this object. Type Object toString() Convert object into string. Source: chronoman.js, line 851 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
