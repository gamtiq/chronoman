<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"chronoman.js.html":{"id":"chronoman.js.html","title":"Source: chronoman.js","body":" chronoman Modules chronoman Classes chronoman~Timer Source: chronoman.js /** * @module chronoman * * @author Denis Sikuler */ if (! Array.isArray) { Array.isArray = function(value) { return Object.prototype.toString.call(value) === \"[object Array]\"; }; } /** * Generate random number or randomly select item from specified array. * * @param {Array | number} start * Array from which an item should be selected * or minimal point of interval from which random number should be generated. * @param {number} [end=start+1] * Maximal point of interval from which random number should be generated. * @param {boolean} [bInteger=true] * Whether integer number should be returned. * This parameter can be used when value of &lt;code&gt;start&lt;/code&gt; parameter is a number. * @return {*} * Random number when &lt;code&gt;start&lt;/code&gt; parameter is a number * or randomly selected item when &lt;code&gt;start&lt;/code&gt; parameter is an array. */ export function getRandomValue(start, end, bInteger) { var nL, result; if (Array.isArray(start)) { nL = start.length; if (nL) { return start[ nL &gt; 1 ? getRandomValue(0, nL - 1) : 0 ]; } return result; } if (typeof end !== \"number\") { end = start + 1; } if (arguments.length &lt; 3) { bInteger = true; } nL = start + ((end - start) * Math.random()); return bInteger ? Math.round(nL) : nL; } /** * @callback module:chronoman~GetPeriodValue * @param {module:chronoman~Timer} [timer] * @return {module:chronoman~SinglePeriodValue | module:chronoman~SinglePeriodValue[]} */ /** * Object describing properties for generating random time period. * * @typedef {Object} module:chronoman~RandomPeriod * @property {Integer} [end] * Maximal point of interval from which random time period should be generated. * @property {Integer[]} [list] * Array from which a time period should be selected randomly. * @property {Integer} [start] * Minimal point of interval from which random time period should be generated. */ /** * Single value determining time period in milliseconds that is used to schedule related action execution. * * @typedef {Integer | module:chronoman~RandomPeriod} module:chronoman~SinglePeriodValue */ /** * Value determining time period in milliseconds that is used to schedule related action execution. * * @typedef {module:chronoman~SinglePeriodValue | module:chronoman~SinglePeriodValue[] | module:chronoman~GetPeriodValue} module:chronoman~PeriodValue */ /** * Object describing action that should be executed after time period is elapsed. * * @typedef {Object} module:chronoman~ActionObject * @property {Function} execute * Function that should be executed. */ /** * Object describing action that should be executed after time period is elapsed. * * @typedef {Object} module:chronoman~ActionSpec * @property {Object} [context] * &lt;code&gt;this&lt;/code&gt; for function's call. * @property {Function} func * Function that should be executed. */ /** * Action that should be executed after time period is elapsed. * * @typedef {Function | module:chronoman~ActionObject | module:chronoman~ActionSpec} module:chronoman~Action */ /** * Utility class to simplify use of timers created by setTimeout. * * @param {Object} [initValue] * Specifies initial property values. Keys are property names, their values are values of corresponding properties. * See {@link module:chronoman~Timer#setProperties setProperties} for details. * @constructor * @see {@link module:chronoman~Timer#setProperties setProperties} */ var Timer = function Timer(initValue) { var that = this; this._executeTime = []; /** * Handle timeout's end. * * @instance * @method * @protected * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} * @see {@link module:chronoman~Timer#execute execute} */ this._onTimeoutEnd = function() { that._timeoutId = null; that.execute(); }; if (initValue &amp;&amp; typeof initValue === \"object\") { this.setProperties(initValue); } }; /** * Time period in milliseconds, object specifying random time period, array of periods * or function that returns period or array of periods. * A related action will be executed when the period is elapsed. * &lt;br&gt; * When an object is set the used period is selected randomly. * The object can have the following properties: * - &lt;code&gt;list&lt;/code&gt; - a non-empty array of integer numbers from which the period will be selected randomly. * - &lt;code&gt;start&lt;/code&gt; - an integer number representing minimal point of interval * from which random time period should be generated; default value - 0. * - &lt;code&gt;end&lt;/code&gt; - an integer number representing maximal point of interval * from which random time period should be generated; default value - &lt;code&gt;start + 1000&lt;/code&gt;. * * &lt;br&gt; * When array of periods is set the used period is selected in the following way: * first array item (with index 0) specifies period before first action's execution, * second array item (with index 1) specifies period before second action's execution, * and so on. * When quantity of action executions is more than array's length * the last item of array is used as period for subsequent executions. * &lt;br&gt; * When function is set its returned value is used to determine next period. * The timer instance to which the function is associated will be passed as function's parameter. * When function returns an array of periods the array is used to select period before next execution * according to rules described above. * * @protected * @type {module:chronoman~PeriodValue} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._period = null; /** * Return value determining time period that is used to schedule related action execution. * * @return {module:chronoman~PeriodValue} * Value determining time period. * @method * @see {@link module:chronoman~Timer#_period _period} */ Timer.prototype.getPeriod = function() { return this._period; }; /** * Set value determining time period that is used to schedule related action execution. * * @param {module:chronoman~PeriodValue} period * Value determining time period. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_period _period} */ Timer.prototype.setPeriod = function(period) { this._period = period; return this; }; /** * Return time period that will be used to schedule related action execution. * * @param {module:chronoman~PeriodValue} [value=this.getPeriod()] * Value that is used to calculation. * @return {Integer} * Time period in milliseconds. * @method * @see {@link module:chronoman~Timer#_period _period} * @see {@link module:chronoman~Timer#getPeriod getPeriod} * @see {@link module:chronoman~Timer#getExecutionQty getExecutionQty} */ Timer.prototype.getPeriodValue = function(value) { /*jshint laxbreak:true*/ var execQty; var period = value || value === 0 ? value : this.getPeriod(); if (typeof period === \"function\") { period = period(this); } if (Array.isArray(period)) { execQty = this.getExecutionQty(); period = period[ execQty &lt; period.length ? execQty : period.length - 1 ]; } if (period &amp;&amp; typeof period === \"object\") { if (period.list &amp;&amp; period.list.length) { period = getRandomValue(period.list); } else { if (typeof period.start !== \"number\") { period.start = 0; } if (typeof period.end !== \"number\") { period.end = period.start + 1000; } period = getRandomValue(period.start, period.end); } } return period; }; /** * Indicates whether related action should be executed repeatedly. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._recurrent = false; /** * Test whether related action should be executed repeatedly. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if related action should be executed repeatedly, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_recurrent _recurrent} */ Timer.prototype.isRecurrent = function() { return this._recurrent; }; /** * Set or cancel repeating of related action execution. * * @param {Boolean} bRecurrent * &lt;code&gt;true&lt;/code&gt;, if action should be executed repeatedly, &lt;code&gt;false&lt;/code&gt;, if action repeating should be off. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_recurrent _recurrent} */ Timer.prototype.setRecurrent = function(bRecurrent) { this._recurrent = bRecurrent; return this; }; /** * Specifies how many times related action should be repeated after first execution. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._repeatQty = 0; /** * Return the value that indicates how many times related action should be repeated after first execution. * * @return {Integer} * Value that indicates how many times related action should be repeated after first execution. * @method * @see {@link module:chronoman~Timer#_repeatQty _repeatQty} */ Timer.prototype.getRepeatQty = function() { return this._repeatQty; }; /** * Set how many times related action should be repeated after first execution. * * @param {Integer} nQty * Value that indicates how many times related action should be repeated after first execution. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_repeatQty _repeatQty} */ Timer.prototype.setRepeatQty = function(nQty) { this._repeatQty = nQty; return this; }; /** * Specifies function that should be called after action execution to determine * whether execution should be repeated. * If the function returns a true value or non-negative number it means that execution will be repeated. * When the function returns non-negative number, array, object or function this value will be used * to calculate time period in milliseconds to schedule next action execution * (see {@link module:chronoman~Timer#getPeriodValue getPeriodValue}). * &lt;br&gt; * The timer instance to which the test is associated will be passed as function's parameter. * * @protected * @type {Function} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._repeatTest = null; /** * Return the function that is used to determine whether action execution should be repeated. * * @return {Function} * Function that is used to determine whether action execution should be repeated. * @method * @see {@link module:chronoman~Timer#_repeatTest _repeatTest} */ Timer.prototype.getRepeatTest = function() { return this._repeatTest; }; /** * Set the function that should be used to determine whether action execution should be repeated. * * @param {Function} test * Function that should be used to determine whether action execution should be repeated. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_repeatTest _repeatTest} */ Timer.prototype.setRepeatTest = function(test) { this._repeatTest = test; return this; }; /** * Auxiliary data associated with the timer instance. * * @protected * @type {*} */ Timer.prototype._data = null; /** * Return auxiliary data associated with the timer instance. * * @return {*} * Auxiliary data associated with the timer instance. * @method * @see {@link module:chronoman~Timer#_data _data} */ Timer.prototype.getData = function() { return this._data; }; /** * Set auxiliary data associated with the timer instance. * * @param {*} data * Auxiliary data associated with the timer instance. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_data _data} */ Timer.prototype.setData = function(data) { this._data = data; return this; }; /** * Specifies how many times action was executed. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._executionQty = 0; /** * Return the value that indicates how many times action was executed. * * @return {Integer} * Value that indicates how many times action was executed. * @method * @see {@link module:chronoman~Timer#_executionQty _executionQty} */ Timer.prototype.getExecutionQty = function() { return this._executionQty; }; /** * Set the value that indicates how many times action was executed. * * @param {Integer} nQty * Value that indicates how many times action was executed. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_executionQty _executionQty} */ Timer.prototype.setExecutionQty = function(nQty) { this._executionQty = nQty &gt; 0 ? nQty : 0; return this; }; /** * Timer id. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#_clearTimeout _clearTimeout} * @see {@link module:chronoman~Timer#_setTimeout _setTimeout} */ Timer.prototype._timeoutId = null; /** * Schedule related action execution. * * @param {module:chronoman~PeriodValue} [timeout] * Time period that is used to schedule action execution. * By default the current value of {@link module:chronoman~Timer#getPeriod period} property is used * to determine time period. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @protected * @see {@link module:chronoman~Timer#_clearTimeout _clearTimeout} * @see {@link module:chronoman~Timer#_onTimeoutEnd _onTimeoutEnd} * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#getPeriodValue getPeriodValue} */ Timer.prototype._setTimeout = function(timeout) { \"use strict\"; var period = this.getPeriodValue(timeout); if (typeof period === \"number\") { this._timeoutId = setTimeout(this._onTimeoutEnd, period); } return this; }; /** * Cancel execution of scheduled action. * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @protected * @see {@link module:chronoman~Timer#_setTimeout _setTimeout} * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} */ Timer.prototype._clearTimeout = function() { \"use strict\"; if (this._timeoutId) { clearTimeout(this._timeoutId); this._timeoutId = null; } return this; }; /** * Time when timer was set {@link module:chronoman~Timer#_active active} * (was {@link module:chronoman~Timer#start started}). * * @protected * @type {Integer | null} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start start} */ Timer.prototype._startTime = null; /** * Return time when timer was set active. * * @return {Integer | null} * Time when timer was set active. * @method * @see {@link module:chronoman~Timer#_startTime _startTime} */ Timer.prototype.getStartTime = function() { return this._startTime; }; /** * Time when timer was set {@link module:chronoman~Timer#_active inactive} * (was {@link module:chronoman~Timer#start stopped}). * * @protected * @type {Integer | null} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start stop} */ Timer.prototype._stopTime = null; /** * Return time when timer was set inactive. * * @return {Integer | null} * Time when timer was set inactive. * @method * @see {@link module:chronoman~Timer#_stopTime _stopTime} */ Timer.prototype.getStopTime = function() { return this._stopTime; }; /** * List that contain times when {@link module:chronoman~Timer#execute execute} was called. * * @type {Integer[]} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._executeTime = null; /** * Return list that contain times when {@link module:chronoman~Timer#execute execute} was called. * * @return {Integer[]} * List that contain times when {@link module:chronoman~Timer#execute execute} was called. * @method * @see {@link module:chronoman~Timer#_executeTime _executeTime} */ Timer.prototype.getExecuteTime = function() { return this._executeTime; }; /** * Indicates whether timer is in use. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._active = false; /** * Test whether timer is in use. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if timer is in use, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_active _active} */ Timer.prototype.isActive = function() { return this._active; }; /** * Set or cancel timer usage. * Depending of this schedules related action execution or cancels action execution. * &lt;br&gt; * Consecutive calling with &lt;code&gt;bActive = true&lt;/code&gt; leads to related action execution delaying. * * @param {Boolean} bActive * &lt;code&gt;true&lt;/code&gt; to schedule related action execution, &lt;code&gt;false&lt;/code&gt; to cancel action execution. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_active _active} * @see {@link module:chronoman~Timer#_executionQty _executionQty} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype.setActive = function(bActive) { \"use strict\"; if (bActive &amp;&amp; ! this._active) { this._executionQty = 0; } this._active = bActive; // Consecutive calling with bActive = true leads to action execution delaying this._clearTimeout(); if (bActive) { this._executeTime.length = 0; this._setTimeout(); } this[bActive ? \"_startTime\" : \"_stopTime\"] = new Date().getTime(); return this; }; /** * Start timer usage (make it active). * * @param {module:chronoman~PeriodValue | Object} [property] * Time period in milliseconds that is used to schedule related action execution * (new value for {@link module:chronoman~Timer#setPeriod period} property) * or object that specifies new values for timer properties (see {@link module:chronoman~Timer#setProperties setProperties}). * The current value of {@link module:chronoman~Timer#getPeriod period} property is used by default. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#setPeriod setPeriod} * @see {@link module:chronoman~Timer#setProperties setProperties} * @see {@link module:chronoman~Timer#stop stop} */ Timer.prototype.start = function(property) { \"use strict\"; var propType = typeof property; if (propType === \"number\" || propType === \"function\" || Array.isArray(property)) { this.setPeriod(property); } else if (property &amp;&amp; propType === \"object\") { this.setProperties(property); } return this.setActive(true); }; /** * Stop timer usage (make it inactive). * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start start} */ Timer.prototype.stop = function() { return this.setActive(false); }; /** * Related action that should be executed after time period is elapsed. * &lt;br&gt; * Can be a function, an object having &lt;code&gt;execute&lt;/code&gt; method * or an object with fields &lt;code&gt;func&lt;/code&gt; (function that will be executed) * and &lt;code&gt;context&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt; for function's call). * &lt;br&gt; * The timer instance to which the action is associated will be passed as function's/method's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * * @protected * @type {module:chronoman~Action} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._action = null; /** * Return value that represents action. * * @return {module:chronoman~Action} * Function that represents action. * @method * @see {@link module:chronoman~Timer#_action _action} */ Timer.prototype.getAction = function() { return this._action; }; /** * Set value which represents action that should be executed after time period is elapsed. * * @param {module:chronoman~Action} action * Value that represents action. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_action _action} */ Timer.prototype.setAction = function(action) { this._action = action; return this; }; /** * Indicates whether the timer instance (&lt;code&gt;this&lt;/code&gt;) should be passed into action function when the function is called. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._passToAction = false; /** * Test whether the timer instance should be passed into action function when the function is called. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if the timer instance should be passed, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_passToAction _passToAction} */ Timer.prototype.isPassToAction = function() { return this._passToAction; }; /** * Set or cancel passing of timer instance into action function. * * @param {Boolean} bPass * &lt;code&gt;true&lt;/code&gt;, if the timer instance should be passed into action function, * &lt;code&gt;false&lt;/code&gt;, if the instance should not be passed. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_passToAction _passToAction} */ Timer.prototype.setPassToAction = function(bPass) { this._passToAction = bPass; return this; }; /** * Set timer properties. * * @param {Object} propMap * Specifies property values. Keys are property names, their values are values of corresponding properties. * The following keys (properties) can be specified: * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;Name&lt;/th&gt; * &lt;th&gt;Type&lt;/th&gt; * &lt;th&gt;Description&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;action&lt;/td&gt; * &lt;td&gt;Function&lt;/td&gt; * &lt;td&gt;Related action that should be executed after time period is elapsed.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;active&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether timer usage should be immediately started.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;data&lt;/td&gt; * &lt;td&gt;Any&lt;/td&gt; * &lt;td&gt;Auxiliary data associated with the timer instance.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;passToAction&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether the timer instance should be passed into action function when the function is called.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;period&lt;/td&gt; * &lt;td&gt;module:chronoman~PeriodValue&lt;/td&gt; * &lt;td&gt;Value determining time period in milliseconds that is used to schedule related action execution.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;recurrent&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether related action should be executed repeatedly.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;repeatQty&lt;/td&gt; * &lt;td&gt;Integer&lt;/td&gt; * &lt;td&gt;How many times related action should be repeated after first execution.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;repeatTest&lt;/td&gt; * &lt;td&gt;Function&lt;/td&gt; * &lt;td&gt;Function that should be used to determine whether action execution should be repeated.&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setAction setAction} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#setData setData} * @see {@link module:chronoman~Timer#setPassToAction setPassToAction} * @see {@link module:chronoman~Timer#setPeriod setPeriod} * @see {@link module:chronoman~Timer#setRecurrent setRecurrent} * @see {@link module:chronoman~Timer#setRepeatQty setRepeatQty} * @see {@link module:chronoman~Timer#setRepeatTest setRepeatTest} */ Timer.prototype.setProperties = function(propMap) { if (propMap &amp;&amp; typeof propMap === \"object\") { if (\"action\" in propMap) { this.setAction(propMap.action); } if (\"period\" in propMap) { this.setPeriod(propMap.period); } if (\"recurrent\" in propMap) { this.setRecurrent(propMap.recurrent); } if (\"repeatQty\" in propMap) { this.setRepeatQty(propMap.repeatQty); } if (\"repeatTest\" in propMap) { this.setRepeatTest(propMap.repeatTest); } if (\"active\" in propMap) { this.setActive(propMap.active); } if (\"passToAction\" in propMap) { this.setPassToAction(propMap.passToAction); } if (\"data\" in propMap) { this.setData(propMap.data); } } return this; }; /** * Result of {@link module:chronoman~Timer#_action action}'s last execution. * * @type {*} * @see {@link module:chronoman~Timer#_action action} */ Timer.prototype.actionResult = void 0; /** * Function that should be executed after time period is elapsed. * &lt;br&gt; * The timer instance to which the function is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * * @type {Function} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype.onExecute = null; /** * Result of {@link module:chronoman~Timer#onExecute onExecute} last execution. * * @type {*} * @see {@link module:chronoman~Timer#onExecute onExecute} */ Timer.prototype.onExecuteResult = void 0; /** * Execute related action (function). * &lt;br&gt; * The timer instance to which the action is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * &lt;br&gt; * Action's next execution will be scheduled when one of the following conditions is true: * &lt;ul&gt; * &lt;li&gt;timer is set as recurrent (see {@link module:chronoman~Timer#isRecurrent isRecurrent}); * &lt;li&gt;specified quantity of repeats is not reached (see {@link module:chronoman~Timer#getRepeatQty getRepeatQty}); * &lt;li&gt;specified repeat test is passed i.e. the test function returns true value or non-negative number (see {@link module:chronoman~Timer#getRepeatTest getRepeatTest}); * &lt;/ul&gt; * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_active _active} * @see {@link module:chronoman~Timer#_executionQty _executionQty} * @see {@link module:chronoman~Timer#getAction getAction} * @see {@link module:chronoman~Timer#getRepeatQty getRepeatQty} * @see {@link module:chronoman~Timer#getRepeatTest getRepeatTest} * @see {@link module:chronoman~Timer#isActive isActive} * @see {@link module:chronoman~Timer#isPassToAction isPassToAction} * @see {@link module:chronoman~Timer#isRecurrent isRecurrent} * @see {@link module:chronoman~Timer#onExecute onExecute} */ Timer.prototype.execute = function() { \"use strict\"; /*jshint expr:true, laxbreak:true*/ var action = this.getAction(), bPassToAction = this.isPassToAction(), repeatTest = this.getRepeatTest(), bActive, period, sType; this._clearTimeout(); if (action) { if (typeof action === \"function\") { this.actionResult = bPassToAction ? action(this) : action(); } else if (typeof action.execute === \"function\") { this.actionResult = bPassToAction ? action.execute(this) : action.execute(); } else if (typeof action.func === \"function\") { this.actionResult = action.func.apply( action.context || action, bPassToAction ? [this] : [] ); } } if (typeof this.onExecute === \"function\") { this.onExecuteResult = bPassToAction ? this.onExecute(this) : this.onExecute(); } this._executionQty++; this._executeTime.push( new Date().getTime() ); bActive = this.isActive(); if (bActive &amp;&amp; (this.isRecurrent() || this.getRepeatQty() &gt;= this._executionQty || (repeatTest &amp;&amp; ( (period = repeatTest(this)) || period === 0 ) &amp;&amp; (sType = typeof period) &amp;&amp; (sType !== \"number\" || period &gt;= 0)) ) ) { this._setTimeout( sType === \"number\" || sType === \"object\" || sType === \"function\" ? period : null ); } else if (bActive &amp;&amp; ! this._timeoutId) { this.setActive(false); } return this; }; /** * Free resources that are allocated for object. * * @method */ Timer.prototype.dispose = function() { \"use strict\"; this._clearTimeout(); this._action = this.actionResult = this._data = this._executeTime = this._period = this._repeatTest = this.onExecute = this.onExecuteResult = null; }; /** * Convert object into string. * * @method */ Timer.prototype.toString = function() { \"use strict\"; /*jshint laxbreak:true*/ var period = this.getPeriod(), startTime = this.getStartTime(), stopTime = this.getStopTime(), executeTime = this.getExecuteTime(), nL = executeTime.length, execTime = \"\", nI; if (nL) { for (nI = 0; nI &lt; nL; nI++) { execTime += (nI ? \"; \" : \"\") + new Date( executeTime[nI] ); } } return [ \"Timer: \", \"active - \", this.isActive(), \", period - \", typeof period === \"function\" ? \"function\" : period, \", recurrent - \", this.isRecurrent(), \", repeat qty - \", this.getRepeatQty(), \", repeat test - \", (this.getRepeatTest() ? \"specified\" : \"no\"), \", pass to action - \", this.isPassToAction(), \", action - \", (this.getAction() ? \"specified\" : \"no\"), \", execution qty - \", this.getExecutionQty(), typeof startTime === \"number\" ? \", start time - \" + new Date(startTime) : \"\", execTime ? \", execute time - \" + execTime : \"\", typeof stopTime === \"number\" ? \", stop time - \" + new Date(stopTime) : \"\", \", action result - \", this.actionResult, \", onExecuteResult - \", this.onExecuteResult, \", data - \", this.getData() ].join(\"\"); }; // Exports export { Timer }; export default Timer; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" chronoman Modules chronoman Classes chronoman~Timer Modules Classes Timer × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" chronoman Modules chronoman Classes chronoman~Timer Classes Classes Timer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" chronoman Modules chronoman Classes chronoman~Timer chronomanUtility class to simplify use of timers created by setTimeout. Features Support for one-time (like setTimeout) or recurrent (like setInterval) timers. It is possible to repeat action indefinitely (recurrent property), specified number of times (repeatQty property) or depending on result of control function (repeatTest property). Time period (timeout) can be: a fixed value, a random value, an item selected from a list depending on action's execution number, or a value returned from specified function. Action that is called can be a function or an object specifying function and its call's context. Action result is saved in timer's field for further access. Timer's start time, stop time and action execution times are saved in startTime, stopTime and executeTime properties correspondingly. var timer = new Timer({ period: [100, 200, 300, 400, 500, {start: 100, end: 500}], repeatQty: 100, passToAction: true, action: function(tmr) { console.log(\"#\", tmr.getExecutionQty() + 1, \":\", new Date()); }, active: true }); ... timer.stop(); InstallationNodenpm install chronomanBowerbower install chronomanAMD, &lt;script&gt;Use dist/chronoman.js or dist/chronoman.min.js (minified version). UsageECMAScript 6/2015import Timer from \"chronoman\";Nodevar Timer = require(\"chronoman\").Timer;AMDdefine([\"path/to/dist/chronoman.js\"], function(chronoman) { var Timer = chronoman.Timer; ... });Bower, &lt;script&gt;&lt;!-- Use bower_components/chronoman/dist/chronoman.js if the library was installed by Bower --&gt; &lt;script type=\"text/javascript\" src=\"path/to/dist/chronoman.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // сhronoman is available via Chronoman field of window object var Timer = Chronoman.Timer; ... &lt;/script&gt;Examplevar tmrOne = new Timer({ period: function(timer) { return 1000 + (timer.getExecutionQty() * 100); }, action: function(timer) { console.log(\"---&gt; Timer one. \", timer); if (! tmrThree.isActive()) { tmrThree.start(); } } }); var tmrTwo = new Timer(); tmrTwo.setPeriod([2000, , {start: 1000, end: 1500}]) .setRepeatQty(9) .setPassToAction(true) .setAction({ i: 0, execute: function(timer) { var nI = ++this.i; console.log(\"Timer two. #\", nI, timer); tmrOne.setActive(nI % 2 === 1); } }); var tmrThree = new Timer() .setPeriod(3000) .setRepeatTest(function() { return tmrTwo.isActive(); }); tmrThree.onExecute = function() { console.log(\"* Timer three. #\", this.getExecutionQty() + 1); }; tmrTwo.start();See test/chronoman.js for additional examples. APISee doc folder. Related projects NumGen povtor InspirationThis module is inspired by qooxdoo's qx.event.Timer class. LicenceCopyright (c) 2013-2020 Denis SikulerLicensed under the MIT license. × Search results Close "},"module-chronoman.html":{"id":"module-chronoman.html","title":"Module: chronoman","body":" chronoman Modules chronoman Classes chronoman~Timer Module: chronoman Author: Denis Sikuler Source: chronoman.js, line 1 Classes Timer Methods &lt;static&gt; getRandomValue(start [, end] [, bInteger]) Generate random number or randomly select item from specified array. Parameters: Name Type Argument Default Description start Array | number Array from which an item should be selected or minimal point of interval from which random number should be generated. end number &lt;optional&gt; start+1 Maximal point of interval from which random number should be generated. bInteger boolean &lt;optional&gt; true Whether integer number should be returned. This parameter can be used when value of start parameter is a number. Source: chronoman.js, line 29 Returns: Random number when start parameter is a number or randomly selected item when start parameter is an array. Type * Type Definitions Action() Action that should be executed after time period is elapsed. Source: chronoman.js, line 98 ActionObject Object describing action that should be executed after time period is elapsed. Type: Object Properties: Name Type Description execute function Function that should be executed. Source: chronoman.js, line 80 ActionSpec Object describing action that should be executed after time period is elapsed. Type: Object Properties: Name Type Argument Description context Object &lt;optional&gt; this for function's call. func function Function that should be executed. Source: chronoman.js, line 88 GetPeriodValue( [timer]) Parameters: Name Type Argument Description timer module:chronoman~Timer &lt;optional&gt; Source: chronoman.js, line 50 Returns: Type module:chronoman~SinglePeriodValue | Array.&lt;module:chronoman~SinglePeriodValue&gt; PeriodValue Value determining time period in milliseconds that is used to schedule related action execution. Type: module:chronoman~SinglePeriodValue | Array.&lt;module:chronoman~SinglePeriodValue&gt; | module:chronoman~GetPeriodValue Source: chronoman.js, line 74 RandomPeriod Object describing properties for generating random time period. Type: Object Properties: Name Type Argument Description end Integer &lt;optional&gt; Maximal point of interval from which random time period should be generated. list Array.&lt;Integer&gt; &lt;optional&gt; Array from which a time period should be selected randomly. start Integer &lt;optional&gt; Minimal point of interval from which random time period should be generated. Source: chronoman.js, line 56 SinglePeriodValue Single value determining time period in milliseconds that is used to schedule related action execution. Type: Integer | module:chronoman~RandomPeriod Source: chronoman.js, line 68 × Search results Close "},"module-chronoman-Timer.html":{"id":"module-chronoman-Timer.html","title":"Class: Timer","body":" chronoman Modules chronoman Classes chronoman~Timer Class: Timer chronoman~ Timer new Timer( [initValue]) Utility class to simplify use of timers created by setTimeout. Parameters: Name Type Argument Description initValue Object &lt;optional&gt; Specifies initial property values. Keys are property names, their values are values of corresponding properties. See setProperties for details. Source: chronoman.js, line 114 See: setProperties Members &lt;protected&gt; _action :module:chronoman~Action Related action that should be executed after time period is elapsed. Can be a function, an object having execute method or an object with fields func (function that will be executed) and context (this for function's call). The timer instance to which the action is associated will be passed as function's/method's parameter if passToAction property is set to true. Type: module:chronoman~Action Source: chronoman.js, line 660 See: execute &lt;protected&gt; _active :Boolean Indicates whether timer is in use. Type: Boolean Source: chronoman.js, line 560 See: execute &lt;protected&gt; _data :* Auxiliary data associated with the timer instance. Type: * Source: chronoman.js, line 366 _executeTime :Array.&lt;Integer&gt; List that contain times when execute was called. Type: Array.&lt;Integer&gt; Source: chronoman.js, line 539 See: execute &lt;protected&gt; _executionQty :Integer Specifies how many times action was executed. Type: Integer Source: chronoman.js, line 403 See: execute setActive &lt;protected&gt; _passToAction :Boolean Indicates whether the timer instance (this) should be passed into action function when the function is called. Type: Boolean Source: chronoman.js, line 696 See: execute &lt;protected&gt; _period :module:chronoman~PeriodValue Time period in milliseconds, object specifying random time period, array of periods or function that returns period or array of periods. A related action will be executed when the period is elapsed. When an object is set the used period is selected randomly. The object can have the following properties: list - a non-empty array of integer numbers from which the period will be selected randomly. start - an integer number representing minimal point of interval from which random time period should be generated; default value - 0. end - an integer number representing maximal point of interval from which random time period should be generated; default value - start + 1000. When array of periods is set the used period is selected in the following way: first array item (with index 0) specifies period before first action's execution, second array item (with index 1) specifies period before second action's execution, and so on. When quantity of action executions is more than array's length the last item of array is used as period for subsequent executions. When function is set its returned value is used to determine next period. The timer instance to which the function is associated will be passed as function's parameter. When function returns an array of periods the array is used to select period before next execution according to rules described above. Type: module:chronoman~PeriodValue Source: chronoman.js, line 171 See: execute setActive &lt;protected&gt; _recurrent :Boolean Indicates whether related action should be executed repeatedly. Type: Boolean Source: chronoman.js, line 250 See: execute setActive &lt;protected&gt; _repeatQty :Integer Specifies how many times related action should be repeated after first execution. Type: Integer Source: chronoman.js, line 287 See: execute setActive &lt;protected&gt; _repeatTest :function Specifies function that should be called after action execution to determine whether execution should be repeated. If the function returns a true value or non-negative number it means that execution will be repeated. When the function returns non-negative number, array, object or function this value will be used to calculate time period in milliseconds to schedule next action execution (see getPeriodValue). The timer instance to which the test is associated will be passed as function's parameter. Type: function Source: chronoman.js, line 331 See: execute setActive &lt;protected&gt; _startTime :Integer|null Time when timer was set active (was started). Type: Integer | null Source: chronoman.js, line 496 See: setActive start &lt;protected&gt; _stopTime :Integer|null Time when timer was set inactive (was stopped). Type: Integer | null Source: chronoman.js, line 519 See: setActive stop &lt;protected&gt; _timeoutId :Integer Timer id. Type: Integer Source: chronoman.js, line 440 See: _clearTimeout _setTimeout actionResult :* Result of action's last execution. Type: * Source: chronoman.js, line 827 See: action onExecute :function Function that should be executed after time period is elapsed. The timer instance to which the function is associated will be passed as function's parameter if passToAction property is set to true. Type: function Source: chronoman.js, line 838 See: execute onExecuteResult :* Result of onExecute last execution. Type: * Source: chronoman.js, line 846 See: onExecute Methods &lt;protected&gt; _clearTimeout() Cancel execution of scheduled action. Source: chronoman.js, line 478 See: _setTimeout _timeoutId Returns: Reference to this object. Type Object &lt;protected&gt; _onTimeoutEnd() Handle timeout's end. Source: chronoman.js, line 129 See: _timeoutId execute &lt;protected&gt; _setTimeout( [timeout]) Schedule related action execution. Parameters: Name Type Argument Description timeout module:chronoman~PeriodValue &lt;optional&gt; Time period that is used to schedule action execution. By default the current value of period property is used to determine time period. Source: chronoman.js, line 459 See: _clearTimeout _onTimeoutEnd _timeoutId execute getPeriodValue Returns: Reference to this object. Type Object dispose() Free resources that are allocated for object. Source: chronoman.js, line 933 execute() Execute related action (function). The timer instance to which the action is associated will be passed as function's parameter if passToAction property is set to true. Action's next execution will be scheduled when one of the following conditions is true: timer is set as recurrent (see isRecurrent); specified quantity of repeats is not reached (see getRepeatQty); specified repeat test is passed i.e. the test function returns true value or non-negative number (see getRepeatTest); Source: chronoman.js, line 874 See: _active _executionQty getAction getRepeatQty getRepeatTest isActive isPassToAction isRecurrent onExecute Returns: Reference to this object. Type Object getAction() Return value that represents action. Source: chronoman.js, line 670 See: _action Returns: Function that represents action. Type module:chronoman~Action getData() Return auxiliary data associated with the timer instance. Source: chronoman.js, line 376 See: _data Returns: Auxiliary data associated with the timer instance. Type * getExecuteTime() Return list that contain times when execute was called. Source: chronoman.js, line 549 See: _executeTime Returns: List that contain times when execute was called. Type Array.&lt;Integer&gt; getExecutionQty() Return the value that indicates how many times action was executed. Source: chronoman.js, line 413 See: _executionQty Returns: Value that indicates how many times action was executed. Type Integer getPeriod() Return value determining time period that is used to schedule related action execution. Source: chronoman.js, line 181 See: _period Returns: Value determining time period. Type module:chronoman~PeriodValue getPeriodValue( [value]) Return time period that will be used to schedule related action execution. Parameters: Name Type Argument Default Description value module:chronoman~PeriodValue &lt;optional&gt; this.getPeriod() Value that is used to calculation. Source: chronoman.js, line 212 See: _period getPeriod getExecutionQty Returns: Time period in milliseconds. Type Integer getRepeatQty() Return the value that indicates how many times related action should be repeated after first execution. Source: chronoman.js, line 297 See: _repeatQty Returns: Value that indicates how many times related action should be repeated after first execution. Type Integer getRepeatTest() Return the function that is used to determine whether action execution should be repeated. Source: chronoman.js, line 341 See: _repeatTest Returns: Function that is used to determine whether action execution should be repeated. Type function getStartTime() Return time when timer was set active. Source: chronoman.js, line 506 See: _startTime Returns: Time when timer was set active. Type Integer | null getStopTime() Return time when timer was set inactive. Source: chronoman.js, line 529 See: _stopTime Returns: Time when timer was set inactive. Type Integer | null isActive() Test whether timer is in use. Source: chronoman.js, line 570 See: _active Returns: true, if timer is in use, otherwise false. Type Boolean isPassToAction() Test whether the timer instance should be passed into action function when the function is called. Source: chronoman.js, line 706 See: _passToAction Returns: true, if the timer instance should be passed, otherwise false. Type Boolean isRecurrent() Test whether related action should be executed repeatedly. Source: chronoman.js, line 260 See: _recurrent Returns: true, if related action should be executed repeatedly, otherwise false. Type Boolean setAction(action) Set value which represents action that should be executed after time period is elapsed. Parameters: Name Type Description action module:chronoman~Action Value that represents action. Source: chronoman.js, line 684 See: _action Returns: Reference to this object. Type Object setActive(bActive) Set or cancel timer usage. Depending of this schedules related action execution or cancels action execution. Consecutive calling with bActive = true leads to related action execution delaying. Parameters: Name Type Description bActive Boolean true to schedule related action execution, false to cancel action execution. Source: chronoman.js, line 589 See: _active _executionQty execute Returns: Reference to this object. Type Object setData(data) Set auxiliary data associated with the timer instance. Parameters: Name Type Description data * Auxiliary data associated with the timer instance. Source: chronoman.js, line 390 See: _data Returns: Reference to this object. Type Object setExecutionQty(nQty) Set the value that indicates how many times action was executed. Parameters: Name Type Description nQty Integer Value that indicates how many times action was executed. Source: chronoman.js, line 427 See: _executionQty Returns: Reference to this object. Type Object setPassToAction(bPass) Set or cancel passing of timer instance into action function. Parameters: Name Type Description bPass Boolean true, if the timer instance should be passed into action function, false, if the instance should not be passed. Source: chronoman.js, line 721 See: _passToAction Returns: Reference to this object. Type Object setPeriod(period) Set value determining time period that is used to schedule related action execution. Parameters: Name Type Description period module:chronoman~PeriodValue Value determining time period. Source: chronoman.js, line 195 See: _period Returns: Reference to this object. Type Object setProperties(propMap) Set timer properties. Parameters: Name Type Description propMap Object Specifies property values. Keys are property names, their values are values of corresponding properties. The following keys (properties) can be specified: Name Type Description action Function Related action that should be executed after time period is elapsed. active Boolean Whether timer usage should be immediately started. data Any Auxiliary data associated with the timer instance. passToAction Boolean Whether the timer instance should be passed into action function when the function is called. period module:chronoman~PeriodValue Value determining time period in milliseconds that is used to schedule related action execution. recurrent Boolean Whether related action should be executed repeatedly. repeatQty Integer How many times related action should be repeated after first execution. repeatTest Function Function that should be used to determine whether action execution should be repeated. Source: chronoman.js, line 791 See: setAction setActive setData setPassToAction setPeriod setRecurrent setRepeatQty setRepeatTest Returns: Reference to this object. Type Object setRecurrent(bRecurrent) Set or cancel repeating of related action execution. Parameters: Name Type Description bRecurrent Boolean true, if action should be executed repeatedly, false, if action repeating should be off. Source: chronoman.js, line 274 See: _recurrent Returns: Reference to this object. Type Object setRepeatQty(nQty) Set how many times related action should be repeated after first execution. Parameters: Name Type Description nQty Integer Value that indicates how many times related action should be repeated after first execution. Source: chronoman.js, line 311 See: _repeatQty Returns: Reference to this object. Type Object setRepeatTest(test) Set the function that should be used to determine whether action execution should be repeated. Parameters: Name Type Description test function Function that should be used to determine whether action execution should be repeated. Source: chronoman.js, line 355 See: _repeatTest Returns: Reference to this object. Type Object start( [property]) Start timer usage (make it active). Parameters: Name Type Argument Description property module:chronoman~PeriodValue | Object &lt;optional&gt; Time period in milliseconds that is used to schedule related action execution (new value for period property) or object that specifies new values for timer properties (see setProperties). The current value of period property is used by default. Source: chronoman.js, line 621 See: setActive setPeriod setProperties stop Returns: Reference to this object. Type Object stop() Stop timer usage (make it inactive). Source: chronoman.js, line 642 See: setActive start Returns: Reference to this object. Type Object toString() Convert object into string. Source: chronoman.js, line 952 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
