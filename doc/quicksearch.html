<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"chronoman.js.html":{"id":"chronoman.js.html","title":"Source: chronoman.js","body":" chronoman Modules chronoman Classes chronoman~Timer Source: chronoman.js /** * @module chronoman * * @author Denis Sikuler */ /** * Utility class to simplify use of timers created by setTimeout. * * @param {Object} [initValue] * Specifies initial property values. Keys are property names, their values are values of corresponding properties. * See {@link module:chronoman~Timer#setProperties setProperties} for details. * @constructor * @see {@link module:chronoman~Timer#setProperties setProperties} */ var Timer = function Timer(initValue) { var that = this; /** * Handle timeout's end. * * @instance * @method * @protected * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} * @see {@link module:chronoman~Timer#execute execute} */ this._onTimeoutEnd = function() { that._timeoutId = null; that.execute(); }; if (initValue &amp;&amp; typeof initValue === \"object\") { this.setProperties(initValue); } }; /** * Time period in milliseconds. * A related action will be executed when the period is elapsed. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._period = null; /** * Return time period that is used to schedule related action execution. * * @return {Integer} * Time period in milliseconds. * @method * @see {@link module:chronoman~Timer#_period _period} */ Timer.prototype.getPeriod = function() { return this._period; }; /** * Set time period that is used to schedule related action execution. * * @param {Integer} nPeriod * Time period in milliseconds. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_period _period} */ Timer.prototype.setPeriod = function(nPeriod) { this._period = nPeriod; return this; }; /** * Indicates whether related action should be executed repeatedly. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._recurrent = false; /** * Test whether related action should be executed repeatedly. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if related action should be executed repeatedly, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_recurrent _recurrent} */ Timer.prototype.isRecurrent = function() { return this._recurrent; }; /** * Set or cancel repeating of related action execution. * * @param {Boolean} bRecurrent * &lt;code&gt;true&lt;/code&gt;, if action should be executed repeatedly, &lt;code&gt;false&lt;/code&gt;, if action repeating should be off. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_recurrent _recurrent} */ Timer.prototype.setRecurrent = function(bRecurrent) { this._recurrent = bRecurrent; return this; }; /** * Specifies how many times related action should be repeated after first execution. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._repeatQty = 0; /** * Return the value that indicates how many times related action should be repeated after first execution. * * @return {Integer} * Value that indicates how many times related action should be repeated after first execution. * @method * @see {@link module:chronoman~Timer#_repeatQty _repeatQty} */ Timer.prototype.getRepeatQty = function() { return this._repeatQty; }; /** * Set how many times related action should be repeated after first execution. * * @param {Integer} nQty * Value that indicates how many times related action should be repeated after first execution. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_repeatQty _repeatQty} */ Timer.prototype.setRepeatQty = function(nQty) { this._repeatQty = nQty; return this; }; /** * Specifies function that should be called after first action execution to determine * whether execution should be repeated. * If the function returns a true value it means that execution will be repeated. * &lt;br&gt; * The timer instance to which the test is associated will be passed as function's parameter. * * @protected * @type {Function} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._repeatTest = null; /** * Return the function that is used to determine whether action execution should be repeated. * * @return {Function} * Function that is used to determine whether action execution should be repeated. * @method * @see {@link module:chronoman~Timer#_repeatTest _repeatTest} */ Timer.prototype.getRepeatTest = function() { return this._repeatTest; }; /** * Set the function that should be used to determine whether action execution should be repeated. * * @param {Function} test * Function that should be used to determine whether action execution should be repeated. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_repeatTest _repeatTest} */ Timer.prototype.setRepeatTest = function(test) { this._repeatTest = test; return this; }; /** * Specifies how many times action was executed. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#setActive setActive} */ Timer.prototype._executionQty = 0; /** * Return the value that indicates how many times action was executed. * * @return {Integer} * Value that indicates how many times action was executed. * @method * @see {@link module:chronoman~Timer#_executionQty _executionQty} */ Timer.prototype.getExecutionQty = function() { return this._executionQty; }; /** * Timer id. * * @protected * @type {Integer} * @see {@link module:chronoman~Timer#_clearTimeout _clearTimeout} * @see {@link module:chronoman~Timer#_setTimeout _setTimeout} */ Timer.prototype._timeoutId = null; /** * Schedule related action execution. * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @protected * @see {@link module:chronoman~Timer#_clearTimeout _clearTimeout} * @see {@link module:chronoman~Timer#_onTimeoutEnd _onTimeoutEnd} * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} * @see {@link module:chronoman~Timer#execute execute} * @see {@link module:chronoman~Timer#getPeriod getPeriod} */ Timer.prototype._setTimeout = function() { \"use strict\"; var nPeriod = this.getPeriod(); if (typeof nPeriod === \"number\") { this._timeoutId = setTimeout(this._onTimeoutEnd, nPeriod); } return this; }; /** * Cancel execution of scheduled action. * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @protected * @see {@link module:chronoman~Timer#_setTimeout _setTimeout} * @see {@link module:chronoman~Timer#_timeoutId _timeoutId} */ Timer.prototype._clearTimeout = function() { \"use strict\"; if (this._timeoutId) { clearTimeout(this._timeoutId); this._timeoutId = null; } return this; }; /** * Indicates whether timer is in use. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._active = false; /** * Test whether timer is in use. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if timer is in use, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_active _active} */ Timer.prototype.isActive = function() { return this._active; }; /** * Set or cancel timer usage. * Depending of this schedules related action execution or cancels action execution. * &lt;br&gt; * Consecutive calling with &lt;code&gt;bActive = true&lt;/code&gt; leads to related action execution delaying. * * @param {Boolean} bActive * &lt;code&gt;true&lt;/code&gt; to schedule related action execution, &lt;code&gt;false&lt;/code&gt; to cancel action execution. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_active _active} * @see {@link module:chronoman~Timer#_executionQty _executionQty} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype.setActive = function(bActive) { \"use strict\"; if (bActive &amp;&amp; ! this._active) { this._executionQty = 0; } this._active = bActive; // Consecutive calling with bActive = true leads to action execution delaying this._clearTimeout(); if (bActive) { this._setTimeout(); } return this; }; /** * Start timer usage (make it active). * * @param {Integer | Object} [property] * Time period in milliseconds that is used to schedule related action execution * (new value for {@link module:chronoman~Timer#setPeriod period} property) * or object that specifies new values for timer properties (see {@link module:chronoman~Timer#setProperties setProperties}). * The current value of {@link module:chronoman~Timer#getPeriod period} property is used by default. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#setPeriod setPeriod} * @see {@link module:chronoman~Timer#setProperties setProperties} * @see {@link module:chronoman~Timer#stop stop} */ Timer.prototype.start = function(property) { \"use strict\"; if (typeof property === \"number\") { this.setPeriod(property); } else if (property &amp;&amp; typeof property === \"object\") { this.setProperties(property); } return this.setActive(true); }; /** * Stop timer usage (make it inactive). * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#start start} */ Timer.prototype.stop = function() { return this.setActive(false); }; /** * Related action that should be executed after time period is elapsed. * &lt;br&gt; * The timer instance to which the action is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * * @protected * @type {Function} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._action = null; /** * Return function that represents action. * * @return {Function} * Function that represents action. * @method * @see {@link module:chronoman~Timer#_action _action} */ Timer.prototype.getAction = function() { return this._action; }; /** * Set function which represents action that should be executed after time period is elapsed. * * @param {Function} action * Function that represents action. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_action _action} */ Timer.prototype.setAction = function(action) { this._action = action; return this; }; /** * Indicates whether the timer instance (&lt;code&gt;this&lt;/code&gt;) should be passed into action function when the function is called. * * @protected * @type {Boolean} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype._passToAction = false; /** * Test whether the timer instance should be passed into action function when the function is called. * * @return {Boolean} * &lt;code&gt;true&lt;/code&gt;, if the timer instance should be passed, otherwise &lt;code&gt;false&lt;/code&gt;. * @method * @see {@link module:chronoman~Timer#_passToAction _passToAction} */ Timer.prototype.isPassToAction = function() { return this._passToAction; }; /** * Set or cancel passing of timer instance into action function. * * @param {Boolean} bPass * &lt;code&gt;true&lt;/code&gt;, if the timer instance should be passed into action function, * &lt;code&gt;false&lt;/code&gt;, if the instance should not be passed. * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_passToAction _passToAction} */ Timer.prototype.setPassToAction = function(bPass) { this._passToAction = bPass; return this; }; /** * Set timer properties. * * @param {Object} propMap * Specifies property values. Keys are property names, their values are values of corresponding properties. * The following keys (properties) can be specified: * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;Name&lt;/th&gt; * &lt;th&gt;Type&lt;/th&gt; * &lt;th&gt;Description&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;action&lt;/td&gt; * &lt;td&gt;Function&lt;/td&gt; * &lt;td&gt;Related action that should be executed after time period is elapsed.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;active&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether timer usage should be immediately started.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;passToAction&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether the timer instance should be passed into action function when the function is called.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;period&lt;/td&gt; * &lt;td&gt;Integer&lt;/td&gt; * &lt;td&gt;Time period in milliseconds that is used to schedule related action execution.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;recurrent&lt;/td&gt; * &lt;td&gt;Boolean&lt;/td&gt; * &lt;td&gt;Whether related action should be executed repeatedly.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;repeatQty&lt;/td&gt; * &lt;td&gt;Integer&lt;/td&gt; * &lt;td&gt;How many times related action should be repeated after first execution.&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;repeatTest&lt;/td&gt; * &lt;td&gt;Function&lt;/td&gt; * &lt;td&gt;Function that should be used to determine whether action execution should be repeated.&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#setAction setAction} * @see {@link module:chronoman~Timer#setActive setActive} * @see {@link module:chronoman~Timer#setPassToAction setPassToAction} * @see {@link module:chronoman~Timer#setPeriod setPeriod} * @see {@link module:chronoman~Timer#setRecurrent setRecurrent} * @see {@link module:chronoman~Timer#setRepeatQty setRepeatQty} * @see {@link module:chronoman~Timer#setRepeatTest setRepeatTest} */ Timer.prototype.setProperties = function(propMap) { if (propMap &amp;&amp; typeof propMap === \"object\") { if (\"action\" in propMap) { this.setAction(propMap.action); } if (\"period\" in propMap) { this.setPeriod(propMap.period); } if (\"recurrent\" in propMap) { this.setRecurrent(propMap.recurrent); } if (\"repeatQty\" in propMap) { this.setRepeatQty(propMap.repeatQty); } if (\"repeatTest\" in propMap) { this.setRepeatTest(propMap.repeatTest); } if (\"active\" in propMap) { this.setActive(propMap.active); } if (\"passToAction\" in propMap) { this.setPassToAction(propMap.passToAction); } } return this; }; /** * Function that should be executed after time period is elapsed. * &lt;br&gt; * The timer instance to which the function is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * * @type {Function} * @see {@link module:chronoman~Timer#execute execute} */ Timer.prototype.onExecute = null; /** * Execute related action (function). * &lt;br&gt; * The timer instance to which the action is associated will be passed as function's parameter * if {@link module:chronoman~Timer#setPassToAction passToAction} property is set to &lt;code&gt;true&lt;/code&gt;. * &lt;br&gt; * Action's next execution will be scheduled when one of the following conditions is true: * &lt;ul&gt; * &lt;li&gt;timer is set as recurrent (see {@link module:chronoman~Timer#isRecurrent isRecurrent}); * &lt;li&gt;specified quantity of repeats is not reached (see {@link module:chronoman~Timer#getRepeatQty getRepeatQty}); * &lt;li&gt;specified repeat test is passed i.e. the test function returns true value (see {@link module:chronoman~Timer#getRepeatTest getRepeatTest}); * &lt;/ul&gt; * * @return {Object} * Reference to &lt;code&gt;this&lt;/code&gt; object. * @method * @see {@link module:chronoman~Timer#_active _active} * @see {@link module:chronoman~Timer#_executionQty _executionQty} * @see {@link module:chronoman~Timer#getAction getAction} * @see {@link module:chronoman~Timer#getRepeatQty getRepeatQty} * @see {@link module:chronoman~Timer#getRepeatTest getRepeatTest} * @see {@link module:chronoman~Timer#isActive isActive} * @see {@link module:chronoman~Timer#isPassToAction isPassToAction} * @see {@link module:chronoman~Timer#isRecurrent isRecurrent} * @see {@link module:chronoman~Timer#onExecute onExecute} */ Timer.prototype.execute = function() { \"use strict\"; /*jshint expr:true, laxbreak:true*/ var action = this.getAction(), bPassToAction = this.isPassToAction(), repeatTest = this.getRepeatTest(), bActive; this._clearTimeout(); if (action) { bPassToAction ? action(this) : action(); } if (typeof this.onExecute === \"function\") { bPassToAction ? this.onExecute(this) : this.onExecute(); } this._executionQty++; bActive = this.isActive(); if (bActive &amp;&amp; (this.isRecurrent() || this.getRepeatQty() &gt;= this._executionQty || (repeatTest &amp;&amp; repeatTest(this)) ) ) { this._setTimeout(); } else if (bActive &amp;&amp; ! this._timeoutId) { this._active = false; } return this; }; /** * Free resources that are allocated for object. * * @method */ Timer.prototype.dispose = function() { \"use strict\"; this._clearTimeout(); this._action = this._repeatTest = this.onExecute = null; }; /** * Convert object into string. * * @method */ Timer.prototype.toString = function() { \"use strict\"; return [ \"Timer: \", \"active - \", this.isActive(), \", period - \", this.getPeriod(), \", recurrent - \", this.isRecurrent(), \", repeat qty - \", this.getRepeatQty(), \", repeat test - \", (this.getRepeatTest() ? \"specified\" : \"no\"), \", pass to action - \", this.isPassToAction(), \", action - \", (this.getAction() ? \"specified\" : \"no\"), \", execution qty - \", this.getExecutionQty() ].join(\"\"); }; // Exports export default Timer; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" chronoman Modules chronoman Classes chronoman~Timer Modules Classes Timer × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" chronoman Modules chronoman Classes chronoman~Timer Classes Classes Timer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" chronoman Modules chronoman Classes chronoman~Timer chronomanUtility class to simplify use of timers created by setTimeout. InstallationNodenpm install chronomanJSPMjspm install chronomanBowerbower install chronomanAMD, &lt;script&gt;Use dist/chronoman.js or dist/chronoman.min.js (minified version). UsageECMAScript 6/2015import Timer from \"chronoman\";Node, JSPMvar Timer = require(\"chronoman\");JSPMSystem.import(\"chronoman\").then(function(Timer) { ... });AMDdefine([\"path/to/dist/chronoman.js\"], function(Timer) { ... });Bower, &lt;script&gt;&lt;!-- Use bower_components/chronoman/dist/chronoman.js if the library was installed by Bower --&gt; &lt;script type=\"text/javascript\" src=\"path/to/dist/chronoman.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // сhronoman is available via Chronoman field of window object var Timer = Chronoman; ... &lt;/script&gt;Examplevar nI = 0; var tmrOne = new Timer({ period: 1000, action: function(timer) { console.log(\"---&gt; Timer one. \", timer); if (! tmrThree.isActive()) { tmrThree.start(); } } }); var tmrTwo = new Timer(); tmrTwo.setPeriod(2000) .setRepeatQty(9) .setPassToAction(true) .setAction(function(timer) { nI++; console.log(\"Timer two. #\", nI, timer); tmrOne.setActive(nI % 2 === 1); }); var tmrThree = new Timer() .setPeriod(3000) .setRepeatTest(function() { return tmrTwo.isActive(); }); tmrThree.onExecute = function() { console.log(\"* Timer three. #\", this.getExecutionQty() + 1); }; tmrTwo.start();APISee doc folder. InspirationThis module is inspired by qooxdoo's qx.event.Timer class. LicenceCopyright (c) 2013-2019 Denis SikulerLicensed under the MIT license. × Search results Close "},"module-chronoman.html":{"id":"module-chronoman.html","title":"Module: chronoman","body":" chronoman Modules chronoman Classes chronoman~Timer Module: chronoman Author: Denis Sikuler Source: chronoman.js, line 1 Classes Timer × Search results Close "},"module-chronoman-Timer.html":{"id":"module-chronoman-Timer.html","title":"Class: Timer","body":" chronoman Modules chronoman Classes chronoman~Timer Class: Timer chronoman~ Timer new Timer( [initValue]) Utility class to simplify use of timers created by setTimeout. Parameters: Name Type Argument Description initValue Object &lt;optional&gt; Specifies initial property values. Keys are property names, their values are values of corresponding properties. See setProperties for details. Source: chronoman.js, line 17 See: setProperties Members &lt;protected&gt; _action :function Related action that should be executed after time period is elapsed. The timer instance to which the action is associated will be passed as function's parameter if passToAction property is set to true. Type: function Source: chronoman.js, line 367 See: execute &lt;protected&gt; _active :Boolean Indicates whether timer is in use. Type: Boolean Source: chronoman.js, line 274 See: execute &lt;protected&gt; _executionQty :Integer Specifies how many times action was executed. Type: Integer Source: chronoman.js, line 202 See: execute setActive &lt;protected&gt; _passToAction :Boolean Indicates whether the timer instance (this) should be passed into action function when the function is called. Type: Boolean Source: chronoman.js, line 403 See: execute &lt;protected&gt; _period :Integer Time period in milliseconds. A related action will be executed when the period is elapsed. Type: Integer Source: chronoman.js, line 50 See: execute setActive &lt;protected&gt; _recurrent :Boolean Indicates whether related action should be executed repeatedly. Type: Boolean Source: chronoman.js, line 87 See: execute setActive &lt;protected&gt; _repeatQty :Integer Specifies how many times related action should be repeated after first execution. Type: Integer Source: chronoman.js, line 124 See: execute setActive &lt;protected&gt; _repeatTest :function Specifies function that should be called after first action execution to determine whether execution should be repeated. If the function returns a true value it means that execution will be repeated. The timer instance to which the test is associated will be passed as function's parameter. Type: function Source: chronoman.js, line 165 See: execute setActive &lt;protected&gt; _timeoutId :Integer Timer id. Type: Integer Source: chronoman.js, line 224 See: _clearTimeout _setTimeout onExecute :function Function that should be executed after time period is elapsed. The timer instance to which the function is associated will be passed as function's parameter if passToAction property is set to true. Type: function Source: chronoman.js, line 528 See: execute Methods &lt;protected&gt; _clearTimeout() Cancel execution of scheduled action. Source: chronoman.js, line 258 See: _setTimeout _timeoutId Returns: Reference to this object. Type Object &lt;protected&gt; _onTimeoutEnd() Handle timeout's end. Source: chronoman.js, line 30 See: _timeoutId execute &lt;protected&gt; _setTimeout() Schedule related action execution. Source: chronoman.js, line 239 See: _clearTimeout _onTimeoutEnd _timeoutId execute getPeriod Returns: Reference to this object. Type Object dispose() Free resources that are allocated for object. Source: chronoman.js, line 593 execute() Execute related action (function). The timer instance to which the action is associated will be passed as function's parameter if passToAction property is set to true. Action's next execution will be scheduled when one of the following conditions is true: timer is set as recurrent (see isRecurrent); specified quantity of repeats is not reached (see getRepeatQty); specified repeat test is passed i.e. the test function returns true value (see getRepeatTest); Source: chronoman.js, line 556 See: _active _executionQty getAction getRepeatQty getRepeatTest isActive isPassToAction isRecurrent onExecute Returns: Reference to this object. Type Object getAction() Return function that represents action. Source: chronoman.js, line 377 See: _action Returns: Function that represents action. Type function getExecutionQty() Return the value that indicates how many times action was executed. Source: chronoman.js, line 212 See: _executionQty Returns: Value that indicates how many times action was executed. Type Integer getPeriod() Return time period that is used to schedule related action execution. Source: chronoman.js, line 60 See: _period Returns: Time period in milliseconds. Type Integer getRepeatQty() Return the value that indicates how many times related action should be repeated after first execution. Source: chronoman.js, line 134 See: _repeatQty Returns: Value that indicates how many times related action should be repeated after first execution. Type Integer getRepeatTest() Return the function that is used to determine whether action execution should be repeated. Source: chronoman.js, line 175 See: _repeatTest Returns: Function that is used to determine whether action execution should be repeated. Type function isActive() Test whether timer is in use. Source: chronoman.js, line 284 See: _active Returns: true, if timer is in use, otherwise false. Type Boolean isPassToAction() Test whether the timer instance should be passed into action function when the function is called. Source: chronoman.js, line 413 See: _passToAction Returns: true, if the timer instance should be passed, otherwise false. Type Boolean isRecurrent() Test whether related action should be executed repeatedly. Source: chronoman.js, line 97 See: _recurrent Returns: true, if related action should be executed repeatedly, otherwise false. Type Boolean setAction(action) Set function which represents action that should be executed after time period is elapsed. Parameters: Name Type Description action function Function that represents action. Source: chronoman.js, line 391 See: _action Returns: Reference to this object. Type Object setActive(bActive) Set or cancel timer usage. Depending of this schedules related action execution or cancels action execution. Consecutive calling with bActive = true leads to related action execution delaying. Parameters: Name Type Description bActive Boolean true to schedule related action execution, false to cancel action execution. Source: chronoman.js, line 303 See: _active _executionQty execute Returns: Reference to this object. Type Object setPassToAction(bPass) Set or cancel passing of timer instance into action function. Parameters: Name Type Description bPass Boolean true, if the timer instance should be passed into action function, false, if the instance should not be passed. Source: chronoman.js, line 428 See: _passToAction Returns: Reference to this object. Type Object setPeriod(nPeriod) Set time period that is used to schedule related action execution. Parameters: Name Type Description nPeriod Integer Time period in milliseconds. Source: chronoman.js, line 74 See: _period Returns: Reference to this object. Type Object setProperties(propMap) Set timer properties. Parameters: Name Type Description propMap Object Specifies property values. Keys are property names, their values are values of corresponding properties. The following keys (properties) can be specified: Name Type Description action Function Related action that should be executed after time period is elapsed. active Boolean Whether timer usage should be immediately started. passToAction Boolean Whether the timer instance should be passed into action function when the function is called. period Integer Time period in milliseconds that is used to schedule related action execution. recurrent Boolean Whether related action should be executed repeatedly. repeatQty Integer How many times related action should be repeated after first execution. repeatTest Function Function that should be used to determine whether action execution should be repeated. Source: chronoman.js, line 492 See: setAction setActive setPassToAction setPeriod setRecurrent setRepeatQty setRepeatTest Returns: Reference to this object. Type Object setRecurrent(bRecurrent) Set or cancel repeating of related action execution. Parameters: Name Type Description bRecurrent Boolean true, if action should be executed repeatedly, false, if action repeating should be off. Source: chronoman.js, line 111 See: _recurrent Returns: Reference to this object. Type Object setRepeatQty(nQty) Set how many times related action should be repeated after first execution. Parameters: Name Type Description nQty Integer Value that indicates how many times related action should be repeated after first execution. Source: chronoman.js, line 148 See: _repeatQty Returns: Reference to this object. Type Object setRepeatTest(test) Set the function that should be used to determine whether action execution should be repeated. Parameters: Name Type Description test function Function that should be used to determine whether action execution should be repeated. Source: chronoman.js, line 189 See: _repeatTest Returns: Reference to this object. Type Object start( [property]) Start timer usage (make it active). Parameters: Name Type Argument Description property Integer | Object &lt;optional&gt; Time period in milliseconds that is used to schedule related action execution (new value for period property) or object that specifies new values for timer properties (see setProperties). The current value of period property is used by default. Source: chronoman.js, line 333 See: setActive setPeriod setProperties stop Returns: Reference to this object. Type Object stop() Stop timer usage (make it inactive). Source: chronoman.js, line 353 See: setActive start Returns: Reference to this object. Type Object toString() Convert object into string. Source: chronoman.js, line 607 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
